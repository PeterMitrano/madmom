import argparse
import csv
import glob
import os

from madmom.custom_processors import ImShowOutputProcessor, SaveOutputProcessor, LabelOutputProcessor
from madmom.features.tf_beats import TfRhythmicGroupingPreProcessor
from madmom.processors import process_single, IOProcessor


def main():
    """
    creates an npz file with the network inputs (filtered audio) and labels
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('data_directory')
    parser.add_argument('--fps', action='store', type=float, default=100, help='frames per second [default=100]')
    args = parser.parse_args()

    responses_dir = os.path.join(args.data_directory, "responses")
    samples_dir = os.path.join(args.data_directory, "samples")

    # iterate over each trial (one person taking the study)
    trial_files = glob.glob(os.path.join(responses_dir, "*.csv"), recursive=False)
    sample_responses_dict = {}
    for trial_file in trial_files:
        trial_reader = csv.reader(open(trial_file, 'r'))

        # iterate over each time they heard the various samples
        for sample_instance in trial_reader:
            # iterate over each time stamp at which they indicated the start of a group
            responses = sample_instance[1].split(" ")[1:-1]
            sample_name = sample_instance[1].split(" ")[-1][:-1]

            if sample_name not in sample_responses_dict:
                sample_responses_dict[sample_name] = []

            sample_responses_dict[sample_name].append([float(r) for r in responses])

    for sample_name, responses in sample_responses_dict.items():
        sample_path = os.path.join(samples_dir, sample_name)
        preprocessor = TfRhythmicGroupingPreProcessor()
        if not os.path.exists(sample_path):
            raise ValueError("Sample path {} does not exist.".format(sample_path))

        infile = open(sample_path, 'rb')
        outfile = 'data/dataset.npz'

        save_processor = SaveOutputProcessor()
        imshow_processor = ImShowOutputProcessor()
        label_processor = LabelOutputProcessor(responses, args.fps)

        # create an IOProcessor
        processor = IOProcessor(preprocessor, label_processor)
        process_single(processor, infile, outfile, **vars(args))


if __name__ == '__main__':
    main()
